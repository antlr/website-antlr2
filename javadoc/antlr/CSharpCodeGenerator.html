<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_03) on Mon Mar 22 10:39:12 PST 2004 -->
<TITLE>
CSharpCodeGenerator
</TITLE>

<META NAME="keywords" CONTENT="antlr.CSharpCodeGenerator class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="CSharpCodeGenerator";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
antlr</FONT>
<BR>
Class CSharpCodeGenerator</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by"><A HREF="../antlr/CodeGenerator.html" title="class in antlr">antlr.CodeGenerator</A>
      <IMG SRC="../resources/inherit.gif" ALT="extended by"><B>antlr.CSharpCodeGenerator</B>
</PRE>
<HR>
<DL>
<DT>public class <B>CSharpCodeGenerator</B><DT>extends <A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></DL>

<P>
Generates MyParser.cs, MyLexer.cs and MyParserTokenTypes.cs
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#caseSizeThreshold">caseSizeThreshold</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_antlr.CodeGenerator"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class antlr.<A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../antlr/CodeGenerator.html#TokenTypesFileExt">TokenTypesFileExt</A>, <A HREF="../antlr/CodeGenerator.html#TokenTypesFileSuffix">TokenTypesFileSuffix</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#CSharpCodeGenerator()">CSharpCodeGenerator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a CSharp code-generator using the given Grammar.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#exitIfError()">exitIfError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen()">gen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate the parser, lexer, treeparser, and token types in CSharp</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.ActionElement)">gen</A></B>(antlr.ActionElement&nbsp;action)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.AlternativeBlock)">gen</A></B>(antlr.AlternativeBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.BlockEndElement)">gen</A></B>(antlr.BlockEndElement&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.CharLiteralElement)">gen</A></B>(antlr.CharLiteralElement&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.CharRangeElement)">gen</A></B>(antlr.CharRangeElement&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.LexerGrammar)">gen</A></B>(antlr.LexerGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate the lexer CSharp file</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.OneOrMoreBlock)">gen</A></B>(antlr.OneOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.ParserGrammar)">gen</A></B>(antlr.ParserGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate the parser CSharp file</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.RuleRefElement)">gen</A></B>(antlr.RuleRefElement&nbsp;rr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.StringLiteralElement)">gen</A></B>(antlr.StringLiteralElement&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.TokenRangeElement)">gen</A></B>(antlr.TokenRangeElement&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.TokenRefElement)">gen</A></B>(antlr.TokenRefElement&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.TreeElement)">gen</A></B>(antlr.TreeElement&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.TreeWalkerGrammar)">gen</A></B>(antlr.TreeWalkerGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate the tree-parser CSharp file</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.WildcardElement)">gen</A></B>(antlr.WildcardElement&nbsp;wc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#gen(antlr.ZeroOrMoreBlock)">gen</A></B>(antlr.ZeroOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate code for the given grammar element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genBody(antlr.LexerGrammar)">genBody</A></B>(antlr.LexerGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genBody(antlr.ParserGrammar)">genBody</A></B>(antlr.ParserGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genBody(antlr.TreeWalkerGrammar)">genBody</A></B>(antlr.TreeWalkerGrammar&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;antlr.CSharpBlockFinishingInfo</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genCommonBlock(antlr.AlternativeBlock, boolean)">genCommonBlock</A></B>(antlr.AlternativeBlock&nbsp;blk,
               boolean&nbsp;noTestForSingle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate common code for a block of alternatives; return a
 postscript that needs to be generated at the end of the
 block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genInitFactory(antlr.Grammar)">genInitFactory</A></B>(<A HREF="../antlr/Grammar.html" title="class in antlr">Grammar</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genNextToken()">genNextToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate the nextToken() rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genRule(antlr.RuleSymbol, boolean, int, antlr.TokenManager)">genRule</A></B>(antlr.RuleSymbol&nbsp;s,
        boolean&nbsp;startSymbol,
        int&nbsp;ruleNum,
        antlr.TokenManager&nbsp;tm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gen a named rule block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#genTokenStrings()">genTokenStrings</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a static array containing the names of the tokens,
 indexed by the token type values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#getASTCreateString(antlr.GrammarAtom, java.lang.String)">getASTCreateString</A></B>(antlr.GrammarAtom&nbsp;atom,
                   java.lang.String&nbsp;astCtorArgs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a string for an expression to generate creating of an AST node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#getASTCreateString(java.lang.String)">getASTCreateString</A></B>(java.lang.String&nbsp;astCtorArgs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string expression that creates an AST node using the specified
  AST constructor argument string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#getASTCreateString(antlr.collections.impl.Vector)">getASTCreateString</A></B>(<A HREF="../antlr/collections/impl/Vector.html" title="class in antlr.collections.impl">Vector</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a string for an expression to generate creation of an AST subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#getRangeExpression(int, int[])">getRangeExpression</A></B>(int&nbsp;k,
                   int[]&nbsp;elems)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an expression for testing a contiguous renage of elements</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#getTokenTypesClassName()">getTokenTypesClassName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Helper method that returns the name of the interface/class/enum type for
            token type constants.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#mapTreeId(java.lang.String, antlr.ActionTransInfo)">mapTreeId</A></B>(java.lang.String&nbsp;idParam,
          <A HREF="../antlr/ActionTransInfo.html" title="class in antlr">ActionTransInfo</A>&nbsp;transInfo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map an identifier to it's corresponding tree-node variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#processStringForASTConstructor(java.lang.String)">processStringForASTConstructor</A></B>(java.lang.String&nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process a string for an simple expression for use in xx/action.g
 it is used to cast simple tokens/references to the right type for
 the generated language.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/CSharpCodeGenerator.html#setupOutput(java.lang.String)">setupOutput</A></B>(java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method exists so a subclass, namely VAJCodeGenerator,
  can open the file in its own evil way.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_antlr.CodeGenerator"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class antlr.<A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../antlr/CodeGenerator.html#decodeLexerRuleName(java.lang.String)">decodeLexerRuleName</A>, <A HREF="../antlr/CodeGenerator.html#elementsAreRange(int[])">elementsAreRange</A>, <A HREF="../antlr/CodeGenerator.html#encodeLexerRuleName(java.lang.String)">encodeLexerRuleName</A>, <A HREF="../antlr/CodeGenerator.html#getFIRSTBitSet(java.lang.String, int)">getFIRSTBitSet</A>, <A HREF="../antlr/CodeGenerator.html#getFOLLOWBitSet(java.lang.String, int)">getFOLLOWBitSet</A>, <A HREF="../antlr/CodeGenerator.html#reverseLexerRuleName(java.lang.String)">reverseLexerRuleName</A>, <A HREF="../antlr/CodeGenerator.html#setAnalyzer(antlr.LLkGrammarAnalyzer)">setAnalyzer</A>, <A HREF="../antlr/CodeGenerator.html#setBehavior(antlr.DefineGrammarSymbols)">setBehavior</A>, <A HREF="../antlr/CodeGenerator.html#setTool(antlr.Tool)">setTool</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="caseSizeThreshold"><!-- --></A><H3>
caseSizeThreshold</H3>
<PRE>
public static final int <B>caseSizeThreshold</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../constant-values.html#antlr.CSharpCodeGenerator.caseSizeThreshold">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CSharpCodeGenerator()"><!-- --></A><H3>
CSharpCodeGenerator</H3>
<PRE>
public <B>CSharpCodeGenerator</B>()</PRE>
<DL>
<DD>Create a CSharp code-generator using the given Grammar.
 The caller must still call setTool, setBehavior, and setAnalyzer
 before generating code.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="exitIfError()"><!-- --></A><H3>
exitIfError</H3>
<PRE>
public void <B>exitIfError</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gen()"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>()</PRE>
<DL>
<DD>Generate the parser, lexer, treeparser, and token types in CSharp
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen()">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.ActionElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.ActionElement&nbsp;action)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.ActionElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>action</CODE> - The {...} action to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.AlternativeBlock)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.AlternativeBlock&nbsp;blk)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.AlternativeBlock)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blk</CODE> - The "x|y|z|..." block to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.BlockEndElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.BlockEndElement&nbsp;end)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.BlockEndElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>end</CODE> - The block-end element to generate.  Block-end
 elements are synthesized by the grammar parser to represent
 the end of a block.</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.CharLiteralElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.CharLiteralElement&nbsp;atom)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.CharLiteralElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>atom</CODE> - The character literal reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.CharRangeElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.CharRangeElement&nbsp;r)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.CharRangeElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - The character-range reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.LexerGrammar)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.LexerGrammar&nbsp;g)
         throws java.io.IOException</PRE>
<DL>
<DD>Generate the lexer CSharp file
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.LexerGrammar)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.OneOrMoreBlock)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.OneOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.OneOrMoreBlock)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blk</CODE> - The (...)+ block to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.ParserGrammar)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.ParserGrammar&nbsp;g)
         throws java.io.IOException</PRE>
<DL>
<DD>Generate the parser CSharp file
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.ParserGrammar)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.RuleRefElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.RuleRefElement&nbsp;rr)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.RuleRefElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rr</CODE> - The rule-reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.StringLiteralElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.StringLiteralElement&nbsp;atom)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.StringLiteralElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>atom</CODE> - The string-literal reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.TokenRangeElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.TokenRangeElement&nbsp;r)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.TokenRangeElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - The token-range reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.TokenRefElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.TokenRefElement&nbsp;atom)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.TokenRefElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>atom</CODE> - The token-reference to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.TreeElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.TreeElement&nbsp;t)</PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></B></DD>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.TreeElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.TreeWalkerGrammar)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.TreeWalkerGrammar&nbsp;g)
         throws java.io.IOException</PRE>
<DL>
<DD>Generate the tree-parser CSharp file
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.TreeWalkerGrammar)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.WildcardElement)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.WildcardElement&nbsp;wc)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.WildcardElement)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>wc</CODE> - The wildcard element to generate</DL>
</DD>
</DL>
<HR>

<A NAME="gen(antlr.ZeroOrMoreBlock)"><!-- --></A><H3>
gen</H3>
<PRE>
public void <B>gen</B>(antlr.ZeroOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>Generate code for the given grammar element.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#gen(antlr.ZeroOrMoreBlock)">gen</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>blk</CODE> - The (...)* block to generate</DL>
</DD>
</DL>
<HR>

<A NAME="genBody(antlr.LexerGrammar)"><!-- --></A><H3>
genBody</H3>
<PRE>
public void <B>genBody</B>(antlr.LexerGrammar&nbsp;g)
             throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="genInitFactory(antlr.Grammar)"><!-- --></A><H3>
genInitFactory</H3>
<PRE>
public void <B>genInitFactory</B>(<A HREF="../antlr/Grammar.html" title="class in antlr">Grammar</A>&nbsp;g)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="genBody(antlr.ParserGrammar)"><!-- --></A><H3>
genBody</H3>
<PRE>
public void <B>genBody</B>(antlr.ParserGrammar&nbsp;g)
             throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="genBody(antlr.TreeWalkerGrammar)"><!-- --></A><H3>
genBody</H3>
<PRE>
public void <B>genBody</B>(antlr.TreeWalkerGrammar&nbsp;g)
             throws java.io.IOException</PRE>
<DL>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="genCommonBlock(antlr.AlternativeBlock, boolean)"><!-- --></A><H3>
genCommonBlock</H3>
<PRE>
public antlr.CSharpBlockFinishingInfo <B>genCommonBlock</B>(antlr.AlternativeBlock&nbsp;blk,
                                                     boolean&nbsp;noTestForSingle)</PRE>
<DL>
<DD>Generate common code for a block of alternatives; return a
 postscript that needs to be generated at the end of the
 block.  Other routines may append else-clauses and such for
 error checking before the postfix is generated.  If the
 grammar is a lexer, then generate alternatives in an order
 where alternatives requiring deeper lookahead are generated
 first, and EOF in the lookahead set reduces the depth of
 the lookahead.  @param blk The block to generate @param
 noTestForSingle If true, then it does not generate a test
 for a single alternative.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="genNextToken()"><!-- --></A><H3>
genNextToken</H3>
<PRE>
public void <B>genNextToken</B>()</PRE>
<DL>
<DD>Generate the nextToken() rule.  nextToken() is a synthetic
 lexer rule that is the implicit OR of all user-defined
 lexer rules.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="genRule(antlr.RuleSymbol, boolean, int, antlr.TokenManager)"><!-- --></A><H3>
genRule</H3>
<PRE>
public void <B>genRule</B>(antlr.RuleSymbol&nbsp;s,
                    boolean&nbsp;startSymbol,
                    int&nbsp;ruleNum,
                    antlr.TokenManager&nbsp;tm)</PRE>
<DL>
<DD>Gen a named rule block.
 ASTs are generated for each element of an alternative unless
 the rule or the alternative have a '!' modifier.

 If an alternative defeats the default tree construction, it
 must set <rule>_AST to the root of the returned AST.

 Each alternative that does automatic tree construction, builds
 up root and child list pointers in an ASTPair structure.

 A rule finishes by setting the returnAST variable from the
 ASTPair.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>startSymbol</CODE> - true if the rule is a start symbol (i.e., not referenced elsewhere)</DL>
</DD>
</DL>
<HR>

<A NAME="genTokenStrings()"><!-- --></A><H3>
genTokenStrings</H3>
<PRE>
public void <B>genTokenStrings</B>()</PRE>
<DL>
<DD>Generate a static array containing the names of the tokens,
 indexed by the token type values.  This static array is used
 to format error messages so that the token identifers or literal
 strings are displayed instead of the token numbers.

 If a lexical rule has a paraphrase, use it rather than the
 token label.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="processStringForASTConstructor(java.lang.String)"><!-- --></A><H3>
processStringForASTConstructor</H3>
<PRE>
public java.lang.String <B>processStringForASTConstructor</B>(java.lang.String&nbsp;str)</PRE>
<DL>
<DD>Process a string for an simple expression for use in xx/action.g
 it is used to cast simple tokens/references to the right type for
 the generated language. Basically called for every element in
 the vector to getASTCreateString(vector V)
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#processStringForASTConstructor(java.lang.String)">processStringForASTConstructor</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - A String.</DL>
</DD>
</DL>
<HR>

<A NAME="getASTCreateString(antlr.collections.impl.Vector)"><!-- --></A><H3>
getASTCreateString</H3>
<PRE>
public java.lang.String <B>getASTCreateString</B>(<A HREF="../antlr/collections/impl/Vector.html" title="class in antlr.collections.impl">Vector</A>&nbsp;v)</PRE>
<DL>
<DD>Get a string for an expression to generate creation of an AST subtree.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#getASTCreateString(antlr.collections.impl.Vector)">getASTCreateString</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - A Vector of String, where each element is an expression
          in the target language yielding an AST node.</DL>
</DD>
</DL>
<HR>

<A NAME="getASTCreateString(antlr.GrammarAtom, java.lang.String)"><!-- --></A><H3>
getASTCreateString</H3>
<PRE>
public java.lang.String <B>getASTCreateString</B>(antlr.GrammarAtom&nbsp;atom,
                                           java.lang.String&nbsp;astCtorArgs)</PRE>
<DL>
<DD>Get a string for an expression to generate creating of an AST node
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#getASTCreateString(antlr.GrammarAtom, java.lang.String)">getASTCreateString</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>atom</CODE> - The grammar node for which you are creating the node<DD><CODE>astCtorArgs</CODE> - The text of the arguments to the AST construction</DL>
</DD>
</DL>
<HR>

<A NAME="getASTCreateString(java.lang.String)"><!-- --></A><H3>
getASTCreateString</H3>
<PRE>
public java.lang.String <B>getASTCreateString</B>(java.lang.String&nbsp;astCtorArgs)</PRE>
<DL>
<DD>Returns a string expression that creates an AST node using the specified
  AST constructor argument string.
  Parses the first (possibly only) argument in the supplied AST ctor argument
	string to obtain the token type -- ctorID.

  IF the token type is a valid token symbol AND
	   it has an associated AST node type     AND
	   this is not a #[ID, "T", "ASTType"] constructor
	THEN
	   generate a call to factory.create(ID, Text, token.ASTNodeType())

  #[ID, "T", "ASTType"] constructors are mapped to astFactory.create(ID, "T", "ASTType")

  The supported AST constructor forms are:
		#[ID]
		#[ID, "text"]
  	#[ID, "text", ASTclassname]	-- introduced in 2.7.2
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>astCtorArgs</CODE> - The arguments to the AST constructor</DL>
</DD>
</DL>
<HR>

<A NAME="getRangeExpression(int, int[])"><!-- --></A><H3>
getRangeExpression</H3>
<PRE>
public java.lang.String <B>getRangeExpression</B>(int&nbsp;k,
                                           int[]&nbsp;elems)</PRE>
<DL>
<DD>Return an expression for testing a contiguous renage of elements
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>k</CODE> - The lookahead level<DD><CODE>elems</CODE> - The elements representing the set, usually from BitSet.toArray().
<DT><B>Returns:</B><DD>String containing test expression.</DL>
</DD>
</DL>
<HR>

<A NAME="mapTreeId(java.lang.String, antlr.ActionTransInfo)"><!-- --></A><H3>
mapTreeId</H3>
<PRE>
public java.lang.String <B>mapTreeId</B>(java.lang.String&nbsp;idParam,
                                  <A HREF="../antlr/ActionTransInfo.html" title="class in antlr">ActionTransInfo</A>&nbsp;transInfo)</PRE>
<DL>
<DD>Map an identifier to it's corresponding tree-node variable.
 This is context-sensitive, depending on the rule and alternative
 being generated
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/CodeGenerator.html#mapTreeId(java.lang.String, antlr.ActionTransInfo)">mapTreeId</A></CODE> in class <CODE><A HREF="../antlr/CodeGenerator.html" title="class in antlr">CodeGenerator</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>idParam</CODE> - The identifier name to map
<DT><B>Returns:</B><DD>The mapped id (which may be the same as the input), or null if the mapping is invalid due to duplicates</DL>
</DD>
</DL>
<HR>

<A NAME="setupOutput(java.lang.String)"><!-- --></A><H3>
setupOutput</H3>
<PRE>
public void <B>setupOutput</B>(java.lang.String&nbsp;className)
                 throws java.io.IOException</PRE>
<DL>
<DD>This method exists so a subclass, namely VAJCodeGenerator,
  can open the file in its own evil way.  JavaCodeGenerator
  simply opens a text file...
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getTokenTypesClassName()"><!-- --></A><H3>
getTokenTypesClassName</H3>
<PRE>
public java.lang.String <B>getTokenTypesClassName</B>()</PRE>
<DL>
<DD>Helper method that returns the name of the interface/class/enum type for
            token type constants.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>
