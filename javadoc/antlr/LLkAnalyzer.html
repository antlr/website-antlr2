<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_03) on Mon Mar 22 10:39:14 PST 2004 -->
<TITLE>
LLkAnalyzer
</TITLE>

<META NAME="keywords" CONTENT="antlr.LLkAnalyzer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="LLkAnalyzer";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
antlr</FONT>
<BR>
Class LLkAnalyzer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by"><B>antlr.LLkAnalyzer</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../antlr/GrammarAnalyzer.html" title="interface in antlr">GrammarAnalyzer</A>, <A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>LLkAnalyzer</B><DT>extends java.lang.Object<DT>implements <A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></DL>

<P>
A linear-approximate LL(k) grammar analzyer.

 All lookahead elements are sets of token types.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../antlr/Grammar.html" title="class in antlr"><CODE>Grammar</CODE></A>, 
<A HREF="../antlr/Lookahead.html" title="class in antlr"><CODE>Lookahead</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#DEBUG_ANALYZER">DEBUG_ANALYZER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_antlr.GrammarAnalyzer"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface antlr.<A HREF="../antlr/GrammarAnalyzer.html" title="interface in antlr">GrammarAnalyzer</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../antlr/GrammarAnalyzer.html#LOOKAHEAD_DEPTH_INIT">LOOKAHEAD_DEPTH_INIT</A>, <A HREF="../antlr/GrammarAnalyzer.html#NONDETERMINISTIC">NONDETERMINISTIC</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#LLkAnalyzer(antlr.Tool)">LLkAnalyzer</A></B>(<A HREF="../antlr/Tool.html" title="class in antlr">Tool</A>&nbsp;tool_)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an LLk analyzer</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#deterministic(antlr.AlternativeBlock)">deterministic</A></B>(antlr.AlternativeBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is this block of alternatives LL(k)?  Fill in alternative cache for this block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#deterministic(antlr.OneOrMoreBlock)">deterministic</A></B>(antlr.OneOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is (...)+ block LL(1)?  Fill in alternative cache for this block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#deterministic(antlr.ZeroOrMoreBlock)">deterministic</A></B>(antlr.ZeroOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is (...)* block LL(1)?  Fill in alternative cache for this block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#deterministicImpliedPath(antlr.BlockWithImpliedExitPath)">deterministicImpliedPath</A></B>(antlr.BlockWithImpliedExitPath&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is this (...)* or (...)+ block LL(k)?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#FOLLOW(int, antlr.RuleEndElement)">FOLLOW</A></B>(int&nbsp;k,
       antlr.RuleEndElement&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the lookahead set of whatever follows references to
 the rule associated witht the FOLLOW block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.ActionElement)">look</A></B>(int&nbsp;k,
     antlr.ActionElement&nbsp;action)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Actions are ignored</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.AlternativeBlock)">look</A></B>(int&nbsp;k,
     antlr.AlternativeBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combine the lookahead computed for each alternative</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.BlockEndElement)">look</A></B>(int&nbsp;k,
     antlr.BlockEndElement&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute what follows this place-holder node and possibly
 what begins the associated loop unless the
 node is locked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.CharLiteralElement)">look</A></B>(int&nbsp;k,
     antlr.CharLiteralElement&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return this char as the lookahead if k=1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.CharRangeElement)">look</A></B>(int&nbsp;k,
     antlr.CharRangeElement&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.GrammarAtom)">look</A></B>(int&nbsp;k,
     antlr.GrammarAtom&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.OneOrMoreBlock)">look</A></B>(int&nbsp;k,
     antlr.OneOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The lookahead of a (...)+ block is the combined lookahead of
 all alternatives and, if an empty path is found, the lookahead
 of what follows the block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.RuleBlock)">look</A></B>(int&nbsp;k,
     <A HREF="../antlr/RuleBlock.html" title="class in antlr">RuleBlock</A>&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combine the lookahead computed for each alternative.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.RuleEndElement)">look</A></B>(int&nbsp;k,
     antlr.RuleEndElement&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If not locked or noFOLLOW set, compute FOLLOW of a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.RuleRefElement)">look</A></B>(int&nbsp;k,
     antlr.RuleRefElement&nbsp;rr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the lookahead contributed by a rule reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, java.lang.String)">look</A></B>(int&nbsp;k,
     java.lang.String&nbsp;rule)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the combined lookahead for all productions of a rule.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.StringLiteralElement)">look</A></B>(int&nbsp;k,
     antlr.StringLiteralElement&nbsp;atom)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.SynPredBlock)">look</A></B>(int&nbsp;k,
     antlr.SynPredBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The lookahead of a (...)=> block is the lookahead of
 what follows the block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.TokenRangeElement)">look</A></B>(int&nbsp;k,
     antlr.TokenRangeElement&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.TreeElement)">look</A></B>(int&nbsp;k,
     antlr.TreeElement&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.WildcardElement)">look</A></B>(int&nbsp;k,
     antlr.WildcardElement&nbsp;wc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#look(int, antlr.ZeroOrMoreBlock)">look</A></B>(int&nbsp;k,
     antlr.ZeroOrMoreBlock&nbsp;blk)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The (...)* element is the combined lookahead of the alternatives and what can
  follow the loop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#lookaheadEquivForApproxAndFullAnalysis(antlr.Lookahead[], int)">lookaheadEquivForApproxAndFullAnalysis</A></B>(<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A>[]&nbsp;bset,
                                       int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the first k-1 sets are singleton sets, the appoximate
  lookahead analysis is equivalent to full lookahead analysis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#setGrammar(antlr.Grammar)">setGrammar</A></B>(<A HREF="../antlr/Grammar.html" title="class in antlr">Grammar</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the grammar for the analyzer</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/LLkAnalyzer.html#subruleCanBeInverted(antlr.AlternativeBlock, boolean)">subruleCanBeInverted</A></B>(antlr.AlternativeBlock&nbsp;blk,
                     boolean&nbsp;forLexer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="DEBUG_ANALYZER"><!-- --></A><H3>
DEBUG_ANALYZER</H3>
<PRE>
public boolean <B>DEBUG_ANALYZER</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="LLkAnalyzer(antlr.Tool)"><!-- --></A><H3>
LLkAnalyzer</H3>
<PRE>
public <B>LLkAnalyzer</B>(<A HREF="../antlr/Tool.html" title="class in antlr">Tool</A>&nbsp;tool_)</PRE>
<DL>
<DD>Create an LLk analyzer
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="deterministic(antlr.AlternativeBlock)"><!-- --></A><H3>
deterministic</H3>
<PRE>
public boolean <B>deterministic</B>(antlr.AlternativeBlock&nbsp;blk)</PRE>
<DL>
<DD>Is this block of alternatives LL(k)?  Fill in alternative cache for this block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#deterministic(antlr.AlternativeBlock)">deterministic</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the block is deterministic</DL>
</DD>
</DL>
<HR>

<A NAME="deterministic(antlr.OneOrMoreBlock)"><!-- --></A><H3>
deterministic</H3>
<PRE>
public boolean <B>deterministic</B>(antlr.OneOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>Is (...)+ block LL(1)?  Fill in alternative cache for this block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#deterministic(antlr.OneOrMoreBlock)">deterministic</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the block is deterministic</DL>
</DD>
</DL>
<HR>

<A NAME="deterministic(antlr.ZeroOrMoreBlock)"><!-- --></A><H3>
deterministic</H3>
<PRE>
public boolean <B>deterministic</B>(antlr.ZeroOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>Is (...)* block LL(1)?  Fill in alternative cache for this block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#deterministic(antlr.ZeroOrMoreBlock)">deterministic</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the block is deterministic</DL>
</DD>
</DL>
<HR>

<A NAME="deterministicImpliedPath(antlr.BlockWithImpliedExitPath)"><!-- --></A><H3>
deterministicImpliedPath</H3>
<PRE>
public boolean <B>deterministicImpliedPath</B>(antlr.BlockWithImpliedExitPath&nbsp;blk)</PRE>
<DL>
<DD>Is this (...)* or (...)+ block LL(k)?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the block is deterministic</DL>
</DD>
</DL>
<HR>

<A NAME="FOLLOW(int, antlr.RuleEndElement)"><!-- --></A><H3>
FOLLOW</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>FOLLOW</B>(int&nbsp;k,
                        antlr.RuleEndElement&nbsp;end)</PRE>
<DL>
<DD>Compute the lookahead set of whatever follows references to
 the rule associated witht the FOLLOW block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#FOLLOW(int, antlr.RuleEndElement)">FOLLOW</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.ActionElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.ActionElement&nbsp;action)</PRE>
<DL>
<DD>Actions are ignored
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.ActionElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.AlternativeBlock)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.AlternativeBlock&nbsp;blk)</PRE>
<DL>
<DD>Combine the lookahead computed for each alternative
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.AlternativeBlock)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.BlockEndElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.BlockEndElement&nbsp;end)</PRE>
<DL>
<DD>Compute what follows this place-holder node and possibly
 what begins the associated loop unless the
 node is locked.
 <p>
 if we hit the end of a loop, we have to include
 what tokens can begin the loop as well.  If the start
 node is locked, then we simply found an empty path
 through this subrule while analyzing it.  If the
 start node is not locked, then this node was hit
 during a FOLLOW operation and the FIRST of this
 block must be included in that lookahead computation.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.BlockEndElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.CharLiteralElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.CharLiteralElement&nbsp;atom)</PRE>
<DL>
<DD>Return this char as the lookahead if k=1.
 <p>### Doesn't work for ( 'a' 'b' | 'a' ~'b' ) yet!!!
 <p>
 If the atom has the <tt>not</tt> flag on, then
 create the set complement of the tokenType
 which is the set of all characters referenced
 in the grammar with this char turned off.
 Also remove characters from the set that
 are currently allocated for predicting
 previous alternatives.  This avoids ambiguity
 messages and is more properly what is meant.
 ( 'a' | ~'a' ) implies that the ~'a' is the
 "else" clause.
 <p>
 NOTE: we do <b>NOT</b> include exit path in
 the exclusion set. E.g.,
 ( 'a' | ~'a' )* 'b'
 should exit upon seeing a 'b' during the loop.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.CharLiteralElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.CharRangeElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.CharRangeElement&nbsp;r)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.CharRangeElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.GrammarAtom)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.GrammarAtom&nbsp;atom)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.GrammarAtom)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.OneOrMoreBlock)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.OneOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>The lookahead of a (...)+ block is the combined lookahead of
 all alternatives and, if an empty path is found, the lookahead
 of what follows the block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.OneOrMoreBlock)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.RuleBlock)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      <A HREF="../antlr/RuleBlock.html" title="class in antlr">RuleBlock</A>&nbsp;blk)</PRE>
<DL>
<DD>Combine the lookahead computed for each alternative.
 Lock the node so that no other computation may come back
 on itself--infinite loop.  This also implies infinite left-recursion
 in the grammar (or an error in this algorithm ;)).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.RuleBlock)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.RuleEndElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.RuleEndElement&nbsp;end)</PRE>
<DL>
<DD>If not locked or noFOLLOW set, compute FOLLOW of a rule.
 <p>
 TJP says 8/12/99: not true anymore:
 Lexical rules never compute follow.  They set epsilon and
 the code generator gens code to check for any character.
 The code generator must remove the tokens used to predict
 any previous alts in the same block.
 <p>
 When the last node of a rule is reached and noFOLLOW,
 it implies that a "local" FOLLOW will be computed
 after this call.  I.e.,
 <pre>
		a : b A;
		b : B | ;
		c : b C;
 </pre>
 Here, when computing the look of rule b from rule a,
 we want only {B,EPSILON_TYPE} so that look(b A) will
 be {B,A} not {B,A,C}.
 <p>
 if the end block is not locked and the FOLLOW is
 wanted, the algorithm must compute the lookahead
 of what follows references to this rule.  If
 end block is locked, FOLLOW will return an empty set
 with a cycle to the rule associated with this end block.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.RuleEndElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.RuleRefElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.RuleRefElement&nbsp;rr)</PRE>
<DL>
<DD>Compute the lookahead contributed by a rule reference.

 <p>
 When computing ruleref lookahead, we don't want the FOLLOW
 computation done if an empty path exists for the rule.
 The FOLLOW is too loose of a set...we want only to
 include the "local" FOLLOW or what can follow this
 particular ref to the node.  In other words, we use
 context information to reduce the complexity of the
 analysis and strengthen the parser.

 The noFOLLOW flag is used as a means of restricting
 the FOLLOW to a "local" FOLLOW.  This variable is
 orthogonal to the <tt>lock</tt> variable that prevents
 infinite recursion.  noFOLLOW does not care about what k is.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.RuleRefElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.StringLiteralElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.StringLiteralElement&nbsp;atom)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.StringLiteralElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.SynPredBlock)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.SynPredBlock&nbsp;blk)</PRE>
<DL>
<DD>The lookahead of a (...)=> block is the lookahead of
 what follows the block.  By definition, the syntactic
 predicate block defies static analysis (you want to try it
 out at run-time).  The LOOK of (a)=>A B is A for LL(1)
 ### is this even called?
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.SynPredBlock)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.TokenRangeElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.TokenRangeElement&nbsp;r)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.TokenRangeElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.TreeElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.TreeElement&nbsp;t)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.TreeElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.WildcardElement)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.WildcardElement&nbsp;wc)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.WildcardElement)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, antlr.ZeroOrMoreBlock)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      antlr.ZeroOrMoreBlock&nbsp;blk)</PRE>
<DL>
<DD>The (...)* element is the combined lookahead of the alternatives and what can
  follow the loop.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, antlr.ZeroOrMoreBlock)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="look(int, java.lang.String)"><!-- --></A><H3>
look</H3>
<PRE>
public <A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A> <B>look</B>(int&nbsp;k,
                      java.lang.String&nbsp;rule)</PRE>
<DL>
<DD>Compute the combined lookahead for all productions of a rule.
 If the lookahead returns with epsilon, at least one epsilon
 path exists (one that consumes no tokens).  The noFOLLOW
 flag being set for this endruleblk, indicates that the
 a rule ref invoked this rule.

 Currently only look(RuleRef) calls this.  There is no need
 for the code generator to call this.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#look(int, java.lang.String)">look</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookaheadEquivForApproxAndFullAnalysis(antlr.Lookahead[], int)"><!-- --></A><H3>
lookaheadEquivForApproxAndFullAnalysis</H3>
<PRE>
public static boolean <B>lookaheadEquivForApproxAndFullAnalysis</B>(<A HREF="../antlr/Lookahead.html" title="class in antlr">Lookahead</A>[]&nbsp;bset,
                                                             int&nbsp;k)</PRE>
<DL>
<DD>If the first k-1 sets are singleton sets, the appoximate
  lookahead analysis is equivalent to full lookahead analysis.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setGrammar(antlr.Grammar)"><!-- --></A><H3>
setGrammar</H3>
<PRE>
public void <B>setGrammar</B>(<A HREF="../antlr/Grammar.html" title="class in antlr">Grammar</A>&nbsp;g)</PRE>
<DL>
<DD>Set the grammar for the analyzer
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#setGrammar(antlr.Grammar)">setGrammar</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subruleCanBeInverted(antlr.AlternativeBlock, boolean)"><!-- --></A><H3>
subruleCanBeInverted</H3>
<PRE>
public boolean <B>subruleCanBeInverted</B>(antlr.AlternativeBlock&nbsp;blk,
                                    boolean&nbsp;forLexer)</PRE>
<DL>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../antlr/LLkGrammarAnalyzer.html#subruleCanBeInverted(antlr.AlternativeBlock, boolean)">subruleCanBeInverted</A></CODE> in interface <CODE><A HREF="../antlr/LLkGrammarAnalyzer.html" title="interface in antlr">LLkGrammarAnalyzer</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>
