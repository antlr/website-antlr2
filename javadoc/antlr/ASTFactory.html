<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_03) on Mon Mar 22 10:39:11 PST 2004 -->
<TITLE>
ASTFactory
</TITLE>

<META NAME="keywords" CONTENT="antlr.ASTFactory class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ASTFactory";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
antlr</FONT>
<BR>
Class ASTFactory</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by"><B>antlr.ASTFactory</B>
</PRE>
<HR>
<DL>
<DT>public class <B>ASTFactory</B><DT>extends java.lang.Object</DL>

<P>
AST Support code shared by TreeParser and Parser.
  We use delegation to share code (and have only one
  bit of code to maintain) rather than subclassing
  or superclassing (forces AST support code to be
  loaded even when you don't want to do AST stuff).

  Typically, setASTNodeType is used to specify the
  homogeneous type of node to create, but you can override
  create to make heterogeneous nodes etc...
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#ASTFactory()">ASTFactory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#ASTFactory(java.util.Hashtable)">ASTFactory</A></B>(java.util.Hashtable&nbsp;tokenTypeToClassMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create factory with a specific mapping from token type
  to Java AST node type.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#addASTChild(antlr.ASTPair, antlr.collections.AST)">addASTChild</A></B>(<A HREF="../antlr/ASTPair.html" title="class in antlr">ASTPair</A>&nbsp;currentAST,
            <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;child)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a child to the current AST</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create()">create</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new empty AST node; if the user did not specify
  an AST node type, then create a default one: CommonAST.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(antlr.collections.AST)">create</A></B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;tr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new empty AST node; if the user did not specify
  an AST node type, then create a default one: CommonAST.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(int)">create</A></B>(int&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(int, java.lang.String)">create</A></B>(int&nbsp;type,
       java.lang.String&nbsp;txt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(int, java.lang.String, java.lang.String)">create</A></B>(int&nbsp;type,
       java.lang.String&nbsp;txt,
       java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an AST node with the token type and text passed in, but
  with a specific Java object type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(java.lang.String)">create</A></B>(java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(antlr.Token)">create</A></B>(<A HREF="../antlr/Token.html" title="class in antlr">Token</A>&nbsp;tok)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#create(antlr.Token, java.lang.String)">create</A></B>(<A HREF="../antlr/Token.html" title="class in antlr">Token</A>&nbsp;tok,
       java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ANTLR generates reference to this when you reference a token
  that has a specified heterogeneous AST node type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#dup(antlr.collections.AST)">dup</A></B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy a single node with same Java AST objec type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#dupList(antlr.collections.AST)">dupList</A></B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duplicate tree including siblings of root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#dupTree(antlr.collections.AST)">dupTree</A></B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duplicate a tree, assuming this is a root node of a tree--
 duplicate that node and what's below; ignore siblings of root node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#error(java.lang.String)">error</A></B>(java.lang.String&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To change where error messages go, can subclass/override this method
  and then setASTFactory in Parser and TreeParser.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#getASTNodeType(int)">getASTNodeType</A></B>(int&nbsp;tokenType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a given token type, what is the AST node object type to create
  for it?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#getTokenTypeToASTClassMap()">getTokenTypeToASTClassMap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#make(antlr.collections.AST[])">make</A></B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>[]&nbsp;nodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a tree from a list of nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#make(antlr.collections.impl.ASTArray)">make</A></B>(<A HREF="../antlr/collections/impl/ASTArray.html" title="class in antlr.collections.impl">ASTArray</A>&nbsp;nodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a tree from a list of nodes, where the nodes are contained
 in an ASTArray object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#makeASTRoot(antlr.ASTPair, antlr.collections.AST)">makeASTRoot</A></B>(<A HREF="../antlr/ASTPair.html" title="class in antlr">ASTPair</A>&nbsp;currentAST,
            <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;root)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make an AST the root of current AST</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#setASTNodeClass(java.lang.String)">setASTNodeClass</A></B>(java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#setASTNodeType(java.lang.String)">setASTNodeType</A></B>(java.lang.String&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>since 2.7.1</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#setTokenTypeASTNodeType(int, java.lang.String)">setTokenTypeASTNodeType</A></B>(int&nbsp;tokenType,
                        java.lang.String&nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify an "override" for the Java AST object created for a
  specific token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../antlr/ASTFactory.html#setTokenTypeToASTClassMap(java.util.Hashtable)">setTokenTypeToASTClassMap</A></B>(java.util.Hashtable&nbsp;tokenTypeToClassMap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ASTFactory()"><!-- --></A><H3>
ASTFactory</H3>
<PRE>
public <B>ASTFactory</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="ASTFactory(java.util.Hashtable)"><!-- --></A><H3>
ASTFactory</H3>
<PRE>
public <B>ASTFactory</B>(java.util.Hashtable&nbsp;tokenTypeToClassMap)</PRE>
<DL>
<DD>Create factory with a specific mapping from token type
  to Java AST node type.  Your subclasses of ASTFactory
  can override and reuse the map stuff.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setTokenTypeASTNodeType(int, java.lang.String)"><!-- --></A><H3>
setTokenTypeASTNodeType</H3>
<PRE>
public void <B>setTokenTypeASTNodeType</B>(int&nbsp;tokenType,
                                    java.lang.String&nbsp;className)
                             throws java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Specify an "override" for the Java AST object created for a
  specific token.  It is provided as a convenience so
  you can specify node types dynamically.  ANTLR sets
  the token type mapping automatically from the tokens{...}
  section, but you can change that mapping with this method.
  ANTLR does it's best to statically determine the node
  type for generating parsers, but it cannot deal with
  dynamic values like #[LT(1)].  In this case, it relies
  on the mapping.  Beware differences in the tokens{...}
  section and what you set via this method.  Make sure
  they are the same.

  Set className to null to remove the mapping.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE><DT><B>Since:</B></DT>
  <DD>2.7.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getASTNodeType(int)"><!-- --></A><H3>
getASTNodeType</H3>
<PRE>
public java.lang.Class <B>getASTNodeType</B>(int&nbsp;tokenType)</PRE>
<DL>
<DD>For a given token type, what is the AST node object type to create
  for it?
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>2.7.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addASTChild(antlr.ASTPair, antlr.collections.AST)"><!-- --></A><H3>
addASTChild</H3>
<PRE>
public void <B>addASTChild</B>(<A HREF="../antlr/ASTPair.html" title="class in antlr">ASTPair</A>&nbsp;currentAST,
                        <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;child)</PRE>
<DL>
<DD>Add a child to the current AST
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create()"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>()</PRE>
<DL>
<DD>Create a new empty AST node; if the user did not specify
  an AST node type, then create a default one: CommonAST.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(int)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(int&nbsp;type)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(int, java.lang.String)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(int&nbsp;type,
                  java.lang.String&nbsp;txt)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(int, java.lang.String, java.lang.String)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(int&nbsp;type,
                  java.lang.String&nbsp;txt,
                  java.lang.String&nbsp;className)</PRE>
<DL>
<DD>Create an AST node with the token type and text passed in, but
  with a specific Java object type. Typically called when you
  say @[PLUS,"+",PLUSNode] in an antlr action.
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>2.7.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(antlr.collections.AST)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;tr)</PRE>
<DL>
<DD>Create a new empty AST node; if the user did not specify
  an AST node type, then create a default one: CommonAST.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(antlr.Token)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(<A HREF="../antlr/Token.html" title="class in antlr">Token</A>&nbsp;tok)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(antlr.Token, java.lang.String)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(<A HREF="../antlr/Token.html" title="class in antlr">Token</A>&nbsp;tok,
                  java.lang.String&nbsp;className)</PRE>
<DL>
<DD>ANTLR generates reference to this when you reference a token
  that has a specified heterogeneous AST node type.  This is
  also a special case node creation routine for backward
  compatibility.  Before, ANTLR generated "new T(tokenObject)"
  and so I must call the appropriate constructor not T().
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>2.7.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="create(java.lang.String)"><!-- --></A><H3>
create</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>create</B>(java.lang.String&nbsp;className)</PRE>
<DL>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>2.7.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dup(antlr.collections.AST)"><!-- --></A><H3>
dup</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>dup</B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</PRE>
<DL>
<DD>Copy a single node with same Java AST objec type.
  Ignore the tokenType->Class mapping since you know
  the type of the node, t.getClass(), and doing a dup.

  clone() is not used because we want all AST creation
  to go thru the factory so creation can be
  tracked.  Returns null if t is null.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dupList(antlr.collections.AST)"><!-- --></A><H3>
dupList</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>dupList</B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</PRE>
<DL>
<DD>Duplicate tree including siblings of root.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dupTree(antlr.collections.AST)"><!-- --></A><H3>
dupTree</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>dupTree</B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;t)</PRE>
<DL>
<DD>Duplicate a tree, assuming this is a root node of a tree--
 duplicate that node and what's below; ignore siblings of root node.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="make(antlr.collections.AST[])"><!-- --></A><H3>
make</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>make</B>(<A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>[]&nbsp;nodes)</PRE>
<DL>
<DD>Make a tree from a list of nodes.  The first element in the
  array is the root.  If the root is null, then the tree is
  a simple list not a tree.  Handles null children nodes correctly.
  For example, build(a, b, null, c) yields tree (a b c).  build(null,a,b)
  yields tree (nil a b).
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="make(antlr.collections.impl.ASTArray)"><!-- --></A><H3>
make</H3>
<PRE>
public <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A> <B>make</B>(<A HREF="../antlr/collections/impl/ASTArray.html" title="class in antlr.collections.impl">ASTArray</A>&nbsp;nodes)</PRE>
<DL>
<DD>Make a tree from a list of nodes, where the nodes are contained
 in an ASTArray object
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeASTRoot(antlr.ASTPair, antlr.collections.AST)"><!-- --></A><H3>
makeASTRoot</H3>
<PRE>
public void <B>makeASTRoot</B>(<A HREF="../antlr/ASTPair.html" title="class in antlr">ASTPair</A>&nbsp;currentAST,
                        <A HREF="../antlr/collections/AST.html" title="interface in antlr.collections">AST</A>&nbsp;root)</PRE>
<DL>
<DD>Make an AST the root of current AST
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setASTNodeClass(java.lang.String)"><!-- --></A><H3>
setASTNodeClass</H3>
<PRE>
public void <B>setASTNodeClass</B>(java.lang.String&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setASTNodeType(java.lang.String)"><!-- --></A><H3>
setASTNodeType</H3>
<PRE>
public void <B>setASTNodeType</B>(java.lang.String&nbsp;t)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>since 2.7.1</I>
<P>
<DD>Specify the type of node to create during tree building.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTokenTypeToASTClassMap()"><!-- --></A><H3>
getTokenTypeToASTClassMap</H3>
<PRE>
public java.util.Hashtable <B>getTokenTypeToASTClassMap</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTokenTypeToASTClassMap(java.util.Hashtable)"><!-- --></A><H3>
setTokenTypeToASTClassMap</H3>
<PRE>
public void <B>setTokenTypeToASTClassMap</B>(java.util.Hashtable&nbsp;tokenTypeToClassMap)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="error(java.lang.String)"><!-- --></A><H3>
error</H3>
<PRE>
public void <B>error</B>(java.lang.String&nbsp;e)</PRE>
<DL>
<DD>To change where error messages go, can subclass/override this method
  and then setASTFactory in Parser and TreeParser.  This method removes
  a prior dependency on class antlr.Tool.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>
